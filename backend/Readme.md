# Backend Template for Spotter

## Start the backend

`mvn spring-boot:run`

## Start the backend with test data

If the database is not clean, the test data won't be inserted

`mvn spring-boot:run -Dspring-boot.run.profiles=generateData`

## Start Test Pipeline

Run complete pipeline test before pushing to Repository

`mvn test`

## Conventions

### Naming DTOs

The name of a DTO always starts with the full name of the entity it represents (e.g. "MessageDetailedDto" representing "
Message")

### Naming Services

The name of a service implementation equals the name of the interface with the suffix "Impl" (e.g. "MessageServiceImpl"
implementing "MessageService")

### Interfaces

Interfaces are always at the top level of their package and the implementation is in a subpackage called "impl"

## Tests

### Naming
- givenX_whenY_thenZ (e.g. givenNothing_whenCreate_then400())
    - given: the input data
    - when: method name + optional test characteristics
    - then: what is the expected result

### Test Data
- use explicit test data defined in /basetest/TestData
- note naming conventions described at the top of the class
- assertions test against these predefined constants
- test data should be constructed here and not in the test classes (saving to DB can be necessary in test classes though)

### test service implementations
- Each service has a test class in the corresponding package in "unittests"
- test each method in isolation with:
  - a positive test
  - a negative test for each expected exception (if applicable)
- test each validator with:
  - a positive test
  - a negative test for each expected validation error

### test entities
- Each entity has a test class in the corresponding package in "unittests"
- test only positive for:
  - equals()
  - build()
  - toString()
  - hashCode()

### test repositories
- Each repository has a test class in the corresponding package in "unittests"
- test only positive for:
    - saving of entities
    - custom queries and methods (no autogenerated methods)

### test endpoints
- Each endpoint has a test class in the corresponding package in "integrationtest"
- delete contents of each table that is being accessed during testing in a @BeforeEach method
- test end-to-end functionality with one positive test for each method testing:
  - status code
  - response body

### (optional) test mappers
- test class in the corresponding package in "unittests"
- test only positive for each method (except for @AfterMapping methods)